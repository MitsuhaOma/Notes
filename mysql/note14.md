#### `InnoDB`统计数据

在`内存`中的统计数据，是临时性的，会跟着服务器关闭而被清除

在`磁盘`中的统计数据，则会被永久地保存

通过系统变量`innodb_stats_persistent`来设置控制使用存储方式

**特别地！！！**

基于`innoDB`是以表为单位来收集和存储统计数据的，对于以下讲到的关于表的相关操作，**都可以在创建表的语句中来设置**，不设置的时候则默认使用系统变量的值

----

#### 基于磁盘的永久性统计数据

当存放统计数据到**磁盘**时，会把表的相关统计数据和索引的相关统计数据会分开存放到两个表中：

- `innodb_table_stats`：每条记录对应一个表的统计数据
- `innodb_index_stats`：每条记录对应着一个索引的一个统计项的统计数据

-----

**`innodb_table_stats`**

几个重要字段：

- `n_rows`: 表中记录条数**（估计值）**
- `clustered_index_size`：表的聚簇索引占用的页面数量**（估计值）**
- `sum_of_other_index_sizes`：表的其他索引占用的页面数量**（估计值）**

----

#### 如何估计`n_rows`

**大致过程：**按照一定算法（这里强调的是非纯粹随机），选取几个叶子节点页面，然后计算每个页面中主键值记录数量，然后就算 平均一个页面中主键值的记录数量乘以全部叶子页面的数量就被当成该表的`n_rows`

这个`n_rows`的精确程度，取决于估计时的采样数量，`MySQL`中用系统变量`innodb_stats_persistent_sample_pages`来设置采样数量。

在`InnoDB`中，创建表的时候可以针对性地设置`STATS_SAMPLE_PAGES`，如果不指定，则使用系统变量`innodb_stats_persistent_sample_pages`的值作为该属性的值。

> `clustered_index_size`和`sum_of_other_index_sizes`的值比实际占用的要偏大

----

#### 统计数据更新

两种方式：

- 开启`innodb_stats_auto_recalc`

  默认开启，每个表维护一个变量，这个变量记录了对该表进行增删改的记录条数，如果发生变动的记录数量超过了表大小的`10%`，并且该系统变量打开时，服务器就会重新进行一次统计数据的计算，并且更新`innodb_table_stats`和`innodb_index_stats`表。不过这个过程是异步发生的，会在表中变动的记录数超过了`10%`，会延迟几秒才进行重新计算再更新。

- 手动调用`ANALYZE TABLE`来更新统计信息

  ```mysql
  mysql> ANALYZE TABLE 表名;
  ```

  需要注意的是，`ANALYZE TABLE`语句会立即重新计算统计数据，也就是这个过程是同步的，在表中索引多或者采样页面特别多时这个过程可能会特别慢

  **请不要没事儿就运行一下`ANALYZE TABLE`语句，最好在业务不是很繁忙的时候再运行。**

----

#### 基于内存的非永久性统计数据

`索引列不重复的值的数量`可以用于计算索引列中平均一个值重复的次数，主要应用场景：

- 用于估计单表查询中的单点区间的记录数量
- 用于预估连接查询驱动表的结果集数量

估计索引列不重复值的数量，对`NULL`值的处理：`MySQL`提供了系统变量`innodb_stats_method`，该变量有三个候选值：

- `nulls_equal`:认为所有`NULL`值相等，也是系统变量的默认值。

  > 如果某个索引列中`NULL`值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别多，所以倾向于不使用索引进行访问

- `nulls_unequal`:认为所有`NULL`值不相等

  > 如果某个索引列中`NULL`值特别多的话，这种统计方式会让优化器认为某个列中平均一个值重复次数特别少，所以倾向于使用索引进行访问。

- `nulls_ignored`:直接忽略`NULL`值


> 写在开头：本文为阅读笔记，主要参考了《[MySQL 是怎样运行的：从根儿上理解 MySQL](https://juejin.cn/book/6844733769996304392)》

### 快速查询——Index 索引

> 设想这么一个情况，如果我们要在一堆数据中查找到我们想要的信息。在无序的情况下，我们需要找到我们想要的信息，我们可能只能一一遍历，才能获取我们想要的信息。索引的出现，直接有效地提高了查询性能

#### 知识补充

**存储引擎：**在`MySQL`服务器上负责对表中数据的读取和写入工作的部分，有多种类型，如`InnoDB`、`MyISAM`、`Memory`等。`MySQL`的默认引擎是`InnoDB`，也是我们日常生产中最常用的。

**`InnoDB`：**将表中的数据存储到磁盘上的存储引擎，从而实现持久化的储存，但是`CPU`是无法直接访问磁盘内容的，我们要访问数据的时候，就必须将磁盘中的数据读取到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，为了减少读写磁盘的次数，`InnoDB`选择将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，`InnoDB`中页的大小一般为`16KB`。也就是在一般情况下，一次最少从磁盘中读取`16KB`的内容到内存中，一次最少把内存中的`16KB`内容刷新到磁盘中

**页：**`InnoDB`管理存储空间的基本单位，一个页的大小一般是`16KB`，页有多种类型，用于存放记录的页叫做索引（`Index`）页

-----

#### 聚簇索引——特殊的B+树

**使用：**不需要显示定义，`InnoDB`存储引擎会自动的为我们创建聚簇索引（根据我们设定的主键字段，如果没有设定，会生成一个row_id的隐藏列来作为主键）

**特点：**

- 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
  - 页内的记录按照主键的大小顺序以单向链表的形式组织
  - 存放用户记录的索引页会根据其中用户记录的主键大小顺序以双向链表的形式组织
  - 用于存放目录项记录的页 分为 不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。
- `B+`树的叶子节点存储的是完整的用户记录，存储了所有列的值（包括隐藏列）。

**示意图：**

![聚簇索引](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2a6c7a65f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

----

#### 二级索引

**示意图：**

![](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2a89adfa5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**与聚簇索引的区别：**（假设我们使用了表student，主键为id，其中有多个列，我们用其中的一个列c1来创建二级索引 ）

- 目录项记录中不再是`主键+页号`的搭配，而变成了`c1列+页号+主键`的搭配

  >  再加主键主要是为了防止出现了多个重复值导致无法判断新纪录插入时应该放在哪里的问题

- `B+`树的叶子节点存储的并不是完整的用户记录，而只是`c1列+主键`这两个列的值。

- 使用记录`c1`列的大小进行记录和页的排序，这包括三个方面的含义：
  - 页内的记录是按照`c1`列的大小顺序排成一个单向链表。
  - 存放用户记录的索引页会根据其中用户记录中`c1`列的大小顺序以双向链表的形式组织
  - 用于存放目录项记录的页 分为 不同的层次，在同一层次中的页也是根据页中目录项记录中`c1`列的大小顺序排成一个双向链表

##### 但是！！！

二级索引为了节省空间，在叶子节点处只是存放了用于创建索引的列和主键两个列的值，如果想根据查询到的结果获得完整的用户记录信息，就必须进行一次**回表操作**，即根据主键值再到聚簇索引中去获取完整的用户记录信息

----

#### 联合索引

同时为多个列建立索引，例如对`c1` `c2` 列建立联合索引，即在新建的B+树中按照`c1`、`c2`的大小进行排序，这包含两个含义：

- 先对记录和页按照`c1`列值的大小进行排序
- 在`c1`列值相同的情况下，再根据`c2`列值的大小进行排序

**示意图：**

![](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2b0b70d72?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**从图中可以看出：**

- B+树的叶子节点中存放了三个字段的值，分别是主键，`c1`列，`c2`列（主键+建立联合索引涉及的字段）
- 每条目录页记录则由`c1`列，`c2`列和页号三个部分组成，各条记录先按照`c1`列的值进行排序，如果记录的`c1`列相同，则按照`c2`列的值进行排序

联合索引的**本质**也是二级索引，如果对一张表中`c1`,`c2`,`c3`列建立联合索引，则相当于对`c1`列建立了二级索引，对`c1`列、`c2`列创建了联合索引，对`c1`列、`c2`列、`c3`列创建了联合索引

----

#### B+树的优点：为什么选择B+树

1、相较B树，B+树，所有的数据都按照键值大小顺序存放在同一层的叶子节点上，非叶子节点只存储了键值信息（聚簇索引存储键值信息，联合索引存储建立联合索引的字段和主键值），比起B树每个节点都携带完整数据，使得那些**用于存储目录项记录的索引页**可以记录更多的目录项记录(页大小一般为16KB)， 可以更好地压缩高度，减少查询时的磁盘I/O次数，提高查询性能。

2、叶子节点之间通过双向链表依次按顺序链接，找到数据之后，可以方便地向前或向后遍历。

#### 最左前缀法则

假设有一张表student，其中有两个字段age和name，用age和name字段来创建联合索引`KEY idx_age_name (age, name)`, 此时记录会先比较age，age小的排在前面，age大的排在后面，age相同时，比较name的值，按照字典序，name小的排在前面，name大的排在后面。

当我们想利用联合索引使用带条件的查询语句时，以上述student为例，我们不能用

`mysql> SELECT * FROM student WHERE name LIKE '王%';`

不允许越过更靠近左侧的`age`字段。

允许`mysql> SELECT * FROM student WHERE age = 21 AND name LIKE '王%';`

这个很容易理解，因为在联合索引中，会根据从左到右的顺序对数据进行排序，靠右的字段值的有序是建立在左侧字段已有序的前提之下的，只有当左侧已经被确定了，右侧字段的顺序才有意义。

> 当然如果实在想通过name来查询的话，对name字段建立一个B+树索引就好了。

----

#### 优化建议

1. 主键最好选用与业务无关的**递增字段**，并且主键字段不宜过长。
   - 非单增的字段，会导致，再插入新纪录的时候，为了符合B+树的特性，而频繁地进行页面分裂和记录移位，这会导致性能损耗
   - 非主键索引会携带主键字段，过长的主键值会使非主键索引占用的空间变得过大。

2. 对建立过索引的列使用查询时，不要一股脑地使用 `SELECT *`， 例如在student表中，对name和age建立了联合索引，主键为id，如果只是需要name，age，id的信息，则只使用`SELECT id,name,age`去查询，这样可以省下回表的操作，提高了信息查询的速率。当然如果业务实在需要，优先跟着业务走。

3. 建立索引可以参考列值的基数（某个列中不重复数据的个数），尽量为基数大的列建立索引。基数过小，可能在一个搜索条件下区分度太小，导致需要进行的回表操作过多，在优化器的抉择下，反而会放弃使用`二级索引+回表`的方式，而选择`全表扫描`的方式。

4. 用作索引的列的类型尽量小，在足够表示列内值的前提下

   - 数据类型越小，在查询时进行的比较操作越快
   - 数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘`I/O`带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。

5. 当我们用作索引列储存着比较长的字符串，我们可以考虑选取字符串的前缀来建立索引。例如：

   ```MYSQL
   CREATE TABLE student_info(
       id   INT         NOT NULL,
       name VARCHAR(25) NOT NULL,
       age  TINYINT     NOT NULL,
       PRIMARY KEY(id),
       KEY idx_name_age (name(10), age)
   );
   ```

   过长的字符串不仅会占用更多的存储空间，在比较时，也会花费更多的时间。

   选取前缀建立索引，即节约了空间，又减少了字符串的比较时间，比较推荐。

   但是也需要考虑到选取的前缀能不能达到预期的区分度，如果选取的前缀过短，可能也会导致基数过小的情况出现。

6.  让索引列在比较表达式中单独出现。

   例如对上面的student_info的age建立索引。下面有两个`WHERE`语句：

   1. `WHERE age * 2 < 40`
   2. `WHERE age < 40/2`

   两者语义相同，但是效率却有差别。

   第一种语句，在存储语句中是不会使用索引的，而是选择依次遍历所有的记录，计算表达式的值是否小于40，而第二种语句中`age`以单独列的形式出现，因此可以直接使用B+树索引。

   同理，除了`比较操作`，索引列使用`函数`、`类型转换`等操作，也会使索引无法使用，转而使用全表扫描。

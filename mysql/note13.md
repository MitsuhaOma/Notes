#### `MySQL`的成本简介

**执行成本的组成：**

- `I/O`成本

  从磁盘到内存这个加载的过程损耗的时间

- `CPU`成本

  读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间

对于`InnoDB`存储引擎来说，页是磁盘和内存之间交互的基本单位。`MySQL`规定读取一个页面花费的成本默认为1.0，读取以及检测一条记录是否符合搜索条件的默认成本为0.2。

1.0、0.2这些数字被称为成本常数，

> 不管读取记录是需不需要检测其是否满足搜索条件，其成本都是0.2

----

#### 单表查询的成本

##### 基于成本的优化步骤

1. 根据搜索条件，找出所有可能使用的索引

2. 计算全表扫描的代价

   > 对于`InnoDB`存储引擎来说，全表扫描就是把聚簇索引中的记录都一次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集中，所以需要把聚簇索引对应的页面加载到内存中，然后在检测记录是否符合搜索条件

   查询成本=`I/O`成本+`CPU`成本，所以计算全表扫描的代价需要两个信息：

   - 聚簇索引占用的页面数（索引页数量）（一页1.0）
   - 该表中的记录数（一条0.2）

   > 实际上，我们只需要获得聚簇索引最左侧的叶子节点，再通过双向链表就可以查看所有记录，这意味着全表扫描的时候其实不是所有的B+树节点都需要被访问，但是`MySQL`计算全表扫描`I/O`成本时，是直接使用聚簇索引占用的所有页面数的，不区分使用的与未使用的叶节点

3. 计算使用不同索引执行查询的代价

   > `MySQL`查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本。

   对于使用`二级索引+回表`方式的查询，`MySQL`计算这种查询的成本依赖两个方面的数据：

   - 范围区间数量

     不论某个范围区间的二级索引实际到底占用了多少页面，查询优化器会粗暴的认为读取索引的一个范围区间的`I/O`成本和读取一个页面时相同的（1.0）

   - 需要回表的记录数

     优化器需要计算二级索引的某个范围区间到底包含多少条记录。

     计算过程如下：

     - 步骤一：先根据范围区间的左侧条件，访问索引列对应的`B+`树索引，找到满足条件的第一条记录（`区间最左记录`）。

       > 在B+树中，定位一条记录所花费的时间是常数级别的，这个过程的性能消耗忽略不计

     - 步骤二：根据范围区间的右侧条件，访问访问索引列对应的`B+`树索引，找到满足条件的最后一条记录（`区间最右记录`）。消耗同`区间最左记录`

     - 步骤三：如果`区间最左记录`和`区间最右记录`相隔不太远（在`MySQL 5.7.21`这个版本中，只要相隔不大于10个页面即可），就可以精确统计出满足范围区间条件的二级索引记录条数。

       若相隔过远，则沿着`区间最左记录`向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以`区间最左记录`和`区间最右记录`之间的页面数量即可。

       > `区间最左记录`和`区间最右记录`之间的页面数，根据B+树的结构可以很容易得出，就根据叶子节点的上一层，来得出页面数，如果相隔还是过远，可以根据上上层来得出结果，这个统计过程并不是很耗费性能。

       ![](https://user-gold-cdn.xitu.io/2019/3/20/16998b505d7a278a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

     - 步骤四：通过二级索引获取到记录后，还要做两件事：

       - 根据这些记录的主键值到聚簇索引中做回表操作

         `MySQL`认为回表操作的`I/O`成本相当于访问页面的`I/O`成本（1.0）

       - 回表操作后得到的完整用户记录，然后在检测其他搜索条件是否成立，`CPU`成本为每条0.2

4. 对比各种执行方案的代价，找出成本最低的 那一个

   **特别地**， **基于索引统计数据的成本计算**

   有时候使用索引执行查询可能会用到很多单点区间，比如`IN`语句就很容易产生非常多的单点区间。

   如果不是唯一二级索引，就不能直接确定单点区间对应二级索引记录的总条数，这需要我们后续地计算。

   `index dive`：通过直接访问索引对应的`B+`树来计算某个范围区间对应的索引记录条数的方式

   为了防止大量单点区间的使用，`MySQL`提供了一个系统变量`eq_range_index_dive_limit`，规定了`IN`语句的参数个数小于一定值(`MySQL 5.7.21`为200)时,将使用`index dive`的方式来计算各个单点区间对应的记录条数，如果大于或等于设定值，则使用**`索引统计数据`**，来估算

<<<<<<< HEAD
   在`MySQL`中，会为表中的每一个索引维护一份统计数据，可以使用

   ```mysql
   mysql> SHOW INDEX FROM table1_name;
   ```

   其中会有一个`Cardinality`属性（基数属性），即索引列中不重复值的个数。但对于`InnoDB`而言，这个`Cardinality`属性是一个估计值

   **`索引统计数据`**指：

   - 使用`SHOW TABLE STATUS`所展示出`Rows`值，也就是一个表中有多少条记录
   - 使用`SHOW INDEX`语句展示出的`Cardinality`属性。

   两者结合我们可以算出，平均一个值的重复次数

   ```
   一个值的重复次数 ≈ Rows ÷ Cardinality
   ```

   用重复次数 \* 单点区间个数，就可以知道需要回表的记录数

   ```
   回表的总记录数 = 一个值的重复次数 × 单点区间个数
   ```

   使用统计数据来估计单点区间所对应的索引记录条数比`index dive`简单，但是**十分不精确**。使用统计数据算出来的查询成本与实际所需的成本可能相差十分巨大

5. 调用存储引擎提供的借口进行真正的执行查询

----

#### 连接查询的成本

`MySQL`中连接查询采用的是嵌套循环链接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表链接查询而言，它的查询成本由以下两部分组成：

- 单次查询驱动表的成本
- 多次查询被驱动表的成本（具体查询多少次取决于驱动表查询的结果集中有多少条记录）

我们把对驱动表进行查询后得到的记录条数称之为驱动表的`扇出`（`fanout`）

很明显，驱动表扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。

计算连接查询所使用的成本时，需要计算驱动表的扇出值，有两种情况下计算驱动表的扇出值时需要靠**猜**：

- 如果使用的是全表扫描方式执行的单表查询,那么计算驱动表扇出是需要猜满足搜索条件的记录有多少条。
- 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

> 在`MySQL5.7`之前的版本中，查询优化器在计算驱动器扇出时，如果是使用全表扫描的话，会直接使用表中记录数量作为扇出值；如果是使用索引的话，后就直接使用满足范围条件的索引记录条数作为扇出值（？）
>
> 在`MySQL5.7`中，引入了`condition filtering`的功能，还要去估测剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其本质就是让成本估算更精确，被称之为`启发式规则（heuristic）`

----

#### 两表连接的成本分析

两表连接的成本计算公式：

```
连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 × 单次访问被驱动表的成本
```

对于左连接和右连接而言，一旦确定了连接方式，驱动表也就跟着确定了下来，所以想要得到成本最低的查询方案只需要：

- 分别为驱动表和被驱动表选择成本最低的访问方式。

而对于内连接而言，驱动表和被驱动表位置可以互换，所以需要考虑两个方面的问题：

- 不同的表作为驱动表最终的查询成本可能是不同的，也就是选择考虑最优的表连接顺序。
- 然后分别为驱动表和被驱动表选择成本最低的访问方法。

连接查询成本占大头的部分是`驱动表扇出表 × 单次访问被驱动表的成本`，所以我们优化重点主要是下面两个部分：

- 尽量减少驱动表的扇出
- 对被驱动表的访问成本尽量低

启示：

我们应当尽量在被驱动表的连接列上建立索引，这样就可以使用`ref`访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列。

----

#### 多表连接的成本分析

有n个表连接，就有n！种连接方式。`MySQL`查询优化器就要把这`n！`种方式都算一遍，但是`MySQL`使用了多种减少计算连接顺序的成本的方法：

- 提前结束某种顺序的成本评估
=======
  

5. 调用存储引擎提供的借口进行真正的执行查询

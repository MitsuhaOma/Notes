#### `MySQL`的成本简介

**执行成本的组成：**

- `I/O`成本

  从磁盘到内存这个加载的过程损耗的时间

- `CPU`成本

  读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间

对于`InnoDB`存储引擎来说，页是磁盘和内存之间交互的基本单位。`MySQL`规定读取一个页面花费的成本默认为1.0，读取以及检测一条记录是否符合搜索条件的默认成本为0.2。

1.0、0.2这些数字被称为成本常数，

> 不管读取记录是需不需要检测其是否满足搜索条件，其成本都是0.2

----

#### 单表查询的成本

##### 基于成本的优化步骤

1. 根据搜索条件，找出所有可能使用的索引

2. 计算全表扫描的代价

   > 对于`InnoDB`存储引擎来说，全表扫描就是把聚簇索引中的记录都一次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集中，所以需要把聚簇索引对应的页面加载到内存中，然后在检测记录是否符合搜索条件

   查询成本=`I/O`成本+`CPU`成本，所以计算全表扫描的代价需要两个信息：

   - 聚簇索引占用的页面数（索引页数量）（一页1.0）
   - 该表中的记录数（一条0.2）

   > 实际上，我们只需要获得聚簇索引最左侧的叶子节点，再通过双向链表就可以查看所有记录，这意味着全表扫描的时候其实不是所有的B+树节点都需要被访问，但是`MySQL`计算全表扫描`I/O`成本时，是直接使用聚簇索引占用的所有页面数的，不区分使用的与未使用的叶节点

3. 计算使用不同索引执行查询的代价

   > `MySQL`查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本。

   对于使用`二级索引+回表`方式的查询，`MySQL`计算这种查询的成本依赖两个方面的数据：

   - 范围区间数量

     不论某个范围区间的二级索引实际到底占用了多少页面，查询优化器会粗暴的认为读取索引的一个范围区间的`I/O`成本和读取一个页面时相同的（1.0）

   - 需要回表的记录数

     优化器需要计算二级索引的某个范围区间到底包含多少条记录。

     计算过程如下：

     - 步骤一：先根据范围区间的左侧条件，访问索引列对应的`B+`树索引，找到满足条件的第一条记录（`区间最左记录`）。

       > 在B+树中，定位一条记录所花费的时间是常数级别的，这个过程的性能消耗忽略不计

     - 步骤二：根据范围区间的右侧条件，访问访问索引列对应的`B+`树索引，找到满足条件的最后一条记录（`区间最右记录`）。消耗同`区间最左记录`

     - 步骤三：如果`区间最左记录`和`区间最右记录`相隔不太远（在`MySQL 5.7.21`这个版本中，只要相隔不大于10个页面即可），就可以精确统计出满足范围区间条件的二级索引记录条数。

       若相隔过远，则沿着`区间最左记录`向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以`区间最左记录`和`区间最右记录`之间的页面数量即可。

       > `区间最左记录`和`区间最右记录`之间的页面数，根据B+树的结构可以很容易得出，就根据叶子节点的上一层，来得出页面数，如果相隔还是过远，可以根据上上层来得出结果，这个统计过程并不是很耗费性能。

       ![](https://user-gold-cdn.xitu.io/2019/3/20/16998b505d7a278a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

     - 步骤四：通过二级索引获取到记录后，还要做两件事：

       - 根据这些记录的主键值到聚簇索引中做回表操作

         `MySQL`认为回表操作的`I/O`成本相当于访问页面的`I/O`成本（1.0）

       - 回表操作后得到的完整用户记录，然后在检测其他搜索条件是否成立，`CPU`成本为每条0.2

4. 对比各种执行方案的代价，找出成本最低的 那一个

   **特别地**， **基于索引统计数据的成本计算**

   有时候使用索引执行查询可能会用到很多单点区间，比如`IN`语句就很容易产生非常多的单点区间。

   如果不是唯一二级索引，就不能直接确定单点区间对应二级索引记录的总条数，这需要我们后续地计算。

   `index dive`：通过直接访问索引对应的`B+`树来计算某个范围区间对应的索引记录条数的方式

   为了防止大量单点区间的使用，`MySQL`提供了一个系统变量`eq_range_index_dive_limit`，规定了`IN`语句的参数个数小于一定值(`MySQL 5.7.21`为200)时,将使用`index dive`的方式来计算各个单点区间对应的记录条数，如果大于或等于设定值，则使用**`索引统计数据`**，来估算

   

5. 调用存储引擎提供的借口进行真正的执行查询


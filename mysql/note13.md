#### `MySQL`的成本简介

**执行成本的组成：**

- `I/O`成本

  从磁盘到内存这个加载的过程损耗的时间

- `CPU`成本

  读取以及检测记录是否满足对应的搜索条件、对结果集进行排序等这些操作损耗的时间

对于`InnoDB`存储引擎来说，页是磁盘和内存之间交互的基本单位。`MySQL`规定读取一个页面花费的成本默认为1.0，读取以及检测一条记录是否符合搜索条件的默认成本为0.2。

1.0、0.2这些数字被称为成本常数，

> 不管读取记录是需不需要检测其是否满足搜索条件，其成本都是0.2

----

#### 单表查询的成本

##### 基于成本的优化步骤

1. 根据搜索条件，找出所有可能使用的索引

2. 计算全表扫描的代价

   > 对于`InnoDB`存储引擎来说，全表扫描就是把聚簇索引中的记录都一次和给定的搜索条件做一下比较，把符合搜索条件的记录加入到结果集中，所以需要把聚簇索引对应的页面加载到内存中，然后在检测记录是否符合搜索条件

   查询成本=`I/O`成本+`CPU`成本，所以计算全表扫描的代价需要两个信息：

   - 聚簇索引占用的页面数（索引页数量）（一页1.0）
   - 该表中的记录数（一条0.2）

   > 实际上，我们只需要获得聚簇索引最左侧的叶子节点，再通过双向链表就可以查看所有记录，这意味着全表扫描的时候其实不是所有的B+树节点都需要被访问，但是`MySQL`计算全表扫描`I/O`成本时，是直接使用聚簇索引占用的所有页面数的，不区分使用的与未使用的叶节点

3. 计算使用不同索引执行查询的代价

   > `MySQL`查询优化器先分析使用唯一二级索引的成本，再分析使用普通索引的成本。

   对于使用`二级索引+回表`方式的查询，`MySQL`计算这种查询的成本依赖两个方面的数据：

   - 范围区间数量

     不论某个范围区间的二级索引实际到底占用了多少页面，查询优化器会粗暴的认为读取索引的一个范围区间的`I/O`成本和读取一个页面时相同的（1.0）

   - 需要回表的记录数

     优化器需要计算二级索引的某个范围区间到底包含多少条记录。

     计算过程如下：

     - 步骤一：先根据范围区间的左侧条件，访问索引列对应的`B+`树索引，找到满足条件的第一条记录（`区间最左记录`）。

       > 在B+树中，定位一条记录所花费的时间是常数级别的，这个过程的性能消耗忽略不计

     - 步骤二：根据范围区间的右侧条件，访问访问索引列对应的`B+`树索引，找到满足条件的最后一条记录（`区间最右记录`）。消耗同`区间最左记录`

     - 步骤三：如果`区间最左记录`和`区间最右记录`相隔不太远（在`MySQL 5.7.21`这个版本中，只要相隔不大于10个页面即可），就可以精确统计出满足范围区间条件的二级索引记录条数。

       若相隔过远，则沿着`区间最左记录`向右读10个页面，计算平均每个页面中包含多少记录，然后用这个平均值乘以`区间最左记录`和`区间最右记录`之间的页面数量即可。

       > `区间最左记录`和`区间最右记录`之间的页面数，根据B+树的结构可以很容易得出，就根据叶子节点的上一层，来得出页面数，如果相隔还是过远，可以根据上上层来得出结果，这个统计过程并不是很耗费性能。

       ![](https://user-gold-cdn.xitu.io/2019/3/20/16998b505d7a278a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

     - 步骤四：通过二级索引获取到记录后，还要做两件事：

       - 根据这些记录的主键值到聚簇索引中做回表操作

         `MySQL`认为回表操作的`I/O`成本相当于访问页面的`I/O`成本（1.0）

       - 回表操作后得到的完整用户记录，然后在检测其他搜索条件是否成立，`CPU`成本为每条0.2

4. 对比各种执行方案的代价，找出成本最低的 那一个

   **特别地**， **基于索引统计数据的成本计算**

   有时候使用索引执行查询可能会用到很多单点区间，比如`IN`语句就很容易产生非常多的单点区间。

   如果不是唯一二级索引，就不能直接确定单点区间对应二级索引记录的总条数，这需要我们后续地计算。

   `index dive`：通过直接访问索引对应的`B+`树来计算某个范围区间对应的索引记录条数的方式

   为了防止大量单点区间的使用，`MySQL`提供了一个系统变量`eq_range_index_dive_limit`，规定了`IN`语句的参数个数小于一定值(`MySQL 5.7.21`为200)时,将使用`index dive`的方式来计算各个单点区间对应的记录条数，如果大于或等于设定值，则使用**`索引统计数据`**，来估算

<<<<<<< HEAD
   在`MySQL`中，会为表中的每一个索引维护一份统计数据，可以使用

   ```mysql
   mysql> SHOW INDEX FROM table1_name;
   ```

   其中会有一个`Cardinality`属性（基数属性），即索引列中不重复值的个数。但对于`InnoDB`而言，这个`Cardinality`属性是一个估计值

   **`索引统计数据`**指：

   - 使用`SHOW TABLE STATUS`所展示出`Rows`值，也就是一个表中有多少条记录
   - 使用`SHOW INDEX`语句展示出的`Cardinality`属性。

   两者结合我们可以算出，平均一个值的重复次数

   ```
   一个值的重复次数 ≈ Rows ÷ Cardinality
   ```

   用重复次数 \* 单点区间个数，就可以知道需要回表的记录数

   ```
   回表的总记录数 = 一个值的重复次数 × 单点区间个数
   ```

   使用统计数据来估计单点区间所对应的索引记录条数比`index dive`简单，但是**十分不精确**。使用统计数据算出来的查询成本与实际所需的成本可能相差十分巨大

5. 调用存储引擎提供的借口进行真正的执行查询

----

#### 连接查询的成本

`MySQL`中连接查询采用的是嵌套循环链接算法，驱动表会被访问一次，被驱动表可能会被访问多次，所以对于两表链接查询而言，它的查询成本由以下两部分组成：

- 单次查询驱动表的成本
- 多次查询被驱动表的成本（具体查询多少次取决于驱动表查询的结果集中有多少条记录）

我们把对驱动表进行查询后得到的记录条数称之为驱动表的`扇出`（`fanout`）

很明显，驱动表扇出值越小，对被驱动表的查询次数也就越少，连接查询的总成本也就越低。

计算连接查询所使用的成本时，需要计算驱动表的扇出值，有两种情况下计算驱动表的扇出值时需要靠**猜**：

- 如果使用的是全表扫描方式执行的单表查询,那么计算驱动表扇出是需要猜满足搜索条件的记录有多少条。
- 如果使用的是索引执行的单表扫描，那么计算驱动表扇出的时候需要猜满足除使用到对应索引的搜索条件外的其他搜索条件的记录有多少条。

> 在`MySQL5.7`之前的版本中，查询优化器在计算驱动器扇出时，如果是使用全表扫描的话，会直接使用表中记录数量作为扇出值；如果是使用索引的话，后就直接使用满足范围条件的索引记录条数作为扇出值（？）
>
> 在`MySQL5.7`中，引入了`condition filtering`的功能，还要去估测剩余的那些搜索条件能把驱动表中的记录再过滤多少条，其本质就是让成本估算更精确，被称之为`启发式规则（heuristic）`

----

#### 两表连接的成本分析

两表连接的成本计算公式：

```
连接查询总成本 = 单次访问驱动表的成本 + 驱动表扇出数 × 单次访问被驱动表的成本
```

对于左连接和右连接而言，一旦确定了连接方式，驱动表也就跟着确定了下来，所以想要得到成本最低的查询方案只需要：

- 分别为驱动表和被驱动表选择成本最低的访问方式。

而对于内连接而言，驱动表和被驱动表位置可以互换，所以需要考虑两个方面的问题：

- 不同的表作为驱动表最终的查询成本可能是不同的，也就是选择考虑最优的表连接顺序。
- 然后分别为驱动表和被驱动表选择成本最低的访问方法。

连接查询成本占大头的部分是`驱动表扇出表 × 单次访问被驱动表的成本`，所以我们优化重点主要是下面两个部分：

- 尽量减少驱动表的扇出
- 对被驱动表的访问成本尽量低

启示：

我们应当尽量在被驱动表的连接列上建立索引，这样就可以使用`ref`访问方法来降低访问被驱动表的成本了。如果可以，被驱动表的连接列最好是该表的主键或者唯一二级索引列。

----

#### 多表连接的成本分析

有n个表连接，就有n！种连接方式。`MySQL`查询优化器就要把这`n！`种方式都算一遍，但是`MySQL`使用了多种减少计算连接顺序的成本的方法：

- 提前结束某种顺序的成本评估。

  `MySQL`在计算各种连接顺序的成本之前，会维护一个全局的变量，这个变量表示当前最小的连接查询成本。如果在分析某个连接顺序的成本时，当该成本在进行到其中一步时就已经超过了当前最小的连接查询成本，就不会继续往下分析了

- 系统变量`optimizer_search_depth`

  这个系统变量规定了穷举分析连接顺序的最大次数。很明显，该值越大，成本分析越精确，越容易得到好的执行计划，但是也会消耗更多的时间。反之，则是得到更小局部的最优方案，并且省掉分析更多种连接顺序的成本的时间

- 根据某些规则压根儿就不考虑某些连接顺序

  `启发式规则`（根据以往经验指定的一些规则），不满足这些规则的连接顺序就不分析。系统变量`optimizer_prune_level`来控制是否启用这些启发式规则来实行经验性的筛选

----

#### 调节成本常数

已知的两个`成本常数`：

- 读取一个页面花费的成本默认是`1.0`（一条记录回表花费的成本被认为和读取一个页相当）
- 读取并检测一条记录是否符合搜索条件的成本默认是`0.2`

在`MySQL`中，有`mysql`数据库（系统数据库）中，存放有专门记录成本常数的表：

```mysql
mysql> SHOW TABLES FROM mysql LIKE '%cost%';
+--------------------------+
| Tables_in_mysql (%cost%) |
+--------------------------+
| engine_cost              |
| server_cost              |
+--------------------------+
2 rows in set (0.00 sec)
```

一条语句的执行分成两层：

- `server`层
- 存储引擎层

在`server`层进行连接管理、查询缓存、语法解析、查询优化等操作，在存储引擎层执行具体的数据存取操作。

> 一条语句在`server`层中执行的成本和它对应的表使用的存储引擎无关

----

#### `mysql.server_cost`表

```MYSQL
mysql> SELECT * FROM server_cost;
+------------------------------+------------+---------------------+---------+---------------+
| cost_name                    | cost_value | last_update         | comment | default_value |
+------------------------------+------------+---------------------+---------+---------------+
| disk_temptable_create_cost   |       NULL | 2021-03-08 08:29:15 | NULL    |            20 |
| disk_temptable_row_cost      |       NULL | 2021-03-08 08:29:15 | NULL    |           0.5 |
| key_compare_cost             |       NULL | 2021-03-08 08:29:15 | NULL    |          0.05 |
| memory_temptable_create_cost |       NULL | 2021-03-08 08:29:15 | NULL    |             1 |
| memory_temptable_row_cost    |       NULL | 2021-03-08 08:29:15 | NULL    |           0.1 |
| row_evaluate_cost            |       NULL | 2021-03-08 08:29:15 | NULL    |           0.1 |
+------------------------------+------------+---------------------+---------+---------------+
6 rows in set (0.00 sec)

```

内容分析：

| 成本常数名称                   | 默认值 | 描述                                                         |
| ------------------------------ | ------ | ------------------------------------------------------------ |
| `disk_temptable_create_cost`   | `20.0` | 创建基于磁盘的临时表的成本，如果增大这个值会让优化器尽量少的创建基于磁盘的临时表。 |
| `disk_temptable_row_cost`      | `0.5`  | 向基于磁盘的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于磁盘的临时表。 |
| `key_compare_cost`             | `0.05` | 两条记录做比较操作的成本，多用在排序操作上，如果增大这个值的话会提升`filesort`的成本，让优化器可能更倾向于使用索引完成排序而不是`filesort`。 |
| `memory_temptable_create_cost` | `1.0`  | 创建基于内存的临时表的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。 |
| `memory_temptable_row_cost`    | `0.1`  | 向基于内存的临时表写入或读取一条记录的成本，如果增大这个值的话会让优化器尽量少的创建基于内存的临时表。 |
| `row_evaluate_cost`            | `0.1`  | 这个就是我们之前一直使用的检测一条记录是否符合搜索条件的成本，增大这个值可能让优化器更倾向于使用索引而不是直接全表扫描。 |

> `MySQL`在执行诸如`DISTINCT`查询、分组查询、`Union`查询以及某些特殊条件下的排序查询都可能在内部先创建一个临时表，用这个临时表来辅助完成查询。在数据量大的情况可能创建基于磁盘的临时表；数据量不大时可能创建基于内存的临时表。这个创建临时表和对这个临时表进行写入和读取的操作代价很高。

**修改成本常数的值，操作步骤：**

- 对我们感兴趣的成本常数做更新操作

  ```mysql
  UPDATE mysql.server_cost
     SET cost_value = 0.4
   WHERE cost_name = 'row_evaluate_cost';
  ```

- 让系统重新加载这个表的值。

  ```mysql
  FLUSH OPTIMIZER_COSTS;
  ```

----

#### `mysql.engine_cost`表

`engine_cost表`表中在存储引擎层进行的一些操作对应的`成本常数`，具体内容如下：

```mysql
mysql> SELECT * FROM mysql.engine_cost;
+-------------+-------------+------------------------+------------+---------------------+---------+---------------+
| engine_name | device_type | cost_name              | cost_value | last_update         | comment | default_value |
+-------------+-------------+------------------------+------------+---------------------+---------+---------------+
| default     |           0 | io_block_read_cost     |       NULL | 2021-03-08 08:29:15 | NULL    |             1 |
| default     |           0 | memory_block_read_cost |       NULL | 2021-03-08 08:29:15 | NULL    |          0.25 |
+-------------+-------------+------------------------+------------+---------------------+---------+---------------+
2 rows in set (0.00 sec)

```

- `engine_name`列

  指成本常数适用的存储引擎名称。`defalut`意味着对应的成本常数适用于所有的存储引擎。

- `device_type`列

  指存储引擎使用的设备类型，主要为了区分常规的机械硬盘和固态硬盘，不过在`MySQL 5.7.21`中并没有区分，值默认为`0`

**内容分析**

| 成本常数名称             | 默认值 | 描述                                                         |
| ------------------------ | ------ | ------------------------------------------------------------ |
| `io_block_read_cost`     | `1.0`  | 从磁盘上读取一个块对应的成本。请注意我使用的是`块`，而不是`页`这个词儿。对于`InnoDB`存储引擎来说，一个`页`就是一个块，不过对于`MyISAM`存储引擎来说，默认是以`4096`字节作为一个块的。增大这个值会加重`I/O`成本，可能让优化器更倾向于选择使用索引执行查询而不是执行全表扫描。 |
| `memory_block_read_cost` | `0.25` | 与上一个参数类似，只不过衡量的是从内存中读取一个块对应的成本。 |

**修改成本常数的值，操作步骤：**

- 插入针对某个存储引擎的成本常数

  比如我们想增大`InnoDB`存储引擎页面`I/O`的成本，

  ```mysql
  INSERT INTO mysql.engine_cost
       VALUES ('InnoDB', 0, 'io_block_read_cost, 2.0', CURRENT_TIMESTAMP, 'increase Innodb I/O cost');
  ```

- 让系统重新加载这个表的值。

  ```mysql
  FLUSH OPTIMIZER_COSTS;
  ```

  
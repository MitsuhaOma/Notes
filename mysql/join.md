#### `JOIN`连接

**本质：**各个连接表中的记录都取出来依次匹配的组合加入结果集并返回给用户,其实就是用两张表求笛卡尔积得到的结果集

**示意图：**

![](https://user-gold-cdn.xitu.io/2018/12/25/167e43ab3feccc29?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**语法：**

```mysql
mysql> SELECT * FROM t1, t2, ..., tn;
# 理论上可以链接任意张表，但是表与表的链接所建立的笛卡尔积结果集可能是非常巨大的，我们有必要在连接时就进行过滤
```

**大致执行过程**

1. 确定第一个需要查询的表，即**`驱动表`**，并使用**与驱动表相关的**搜索条件，选取代价最低的单标访问方法执行对驱动表的单表查询，获得结果集
2. 针对上一步骤中从驱动表中产生的结果集中的每一个记录，分别需要到另一个表中去查找符合其他过滤条件的记录，此时，另一张表被称为**`被驱动表`**

> 在两表链接查询中，驱动表只需要访问一次，而被驱动表则需要根据驱动表访问后得到的结果集被访问多次（次数为结果集中记录数）

----

#### 内连接与外链接

**目的：**为了解决驱动表中的记录即使在被驱动表中没有匹配的记录，也需要加入到结果集的需求

**区分：**

- 对于`内连接`的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集。
- 对于`外连接`的两个表，驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。

----

#### 外链接

在`Mysql`中，两表查询，根据选取驱动表的不同，外链接仍然细分为两种：

- 左外链接：选取左侧的表为驱动表
- 右外链接：选取右侧的表为驱动表

**新的需求！！！**我们有时候也并不像将驱动表的全部记录加入到最后的结果集。**因此，加入了两种不同的过滤形式。**

- `WHERE`:通用的过滤条件

  不管是内连接还是外链接，只要不符合`WHERE`中的过滤条件的记录都不会被加入到最后的结果集。

- `ON` 连接条件

  ***仅针对外链接表，***如果无法在被驱动表中找到匹配`ON`中的过滤条件的记录，那么该记录仍会被加入到结果集中，对应的被驱动表记录的各个字段会用`NULL`值填充。

  **在内连接中**，`WHERE`与`ON`等价

> 推荐将`ON`直接记成只能在外链接使用

**语法：**

- 左外链接

  - 使用

    ```mysql
      # 左侧t1为驱动表，右侧t2为被驱动表
      mysql> SELECT * FROM t1 LEFT JOIN t2 ON 链接条件 [WHERE 通用过滤条件]; 
    ```

- 右外链接

  - 使用

    ```mysql
      # 右侧t2为驱动表，左侧t1为被驱动表
      mysql> SELECT * FROM t1 RIGHT JOIN t2 ON 链接条件 [WHERE 通用过滤条件];
    ```


-----

#### 内连接

**语法：**

```mysql
mysql> SELECT * FROM t1 INNER JOIN t2 [ON 连接条件] [WHERE 通用过滤条件];
```

-----

#### 内连接和外连接的区别

| 属性     | 内连接                    | 外链接                                                       |
| -------- | ------------------------- | ------------------------------------------------------------ |
| 根本区别 | `ON`子句作用同`WHERE`子句 | 外链接驱动表中的记录在被驱动表中找不到匹配`ON`子句的过滤条件的记录，那么该记录仍会被加入到结果集中，对应的被驱动表记录的各个字段用`NULL`值填充 |
| 驱动表   | 无驱动表、被驱动表之分    | 根据建立的语法，来选取驱动表、被驱动表                       |

----

#### 链接的原理

重点：`MySQL`用来进行表与表之间的链接时采用的算法

**嵌套循环链(`Nested-Loop Join`)**

已知：驱动表只会被访问一遍，被驱动表则会被访问根据访问驱动表后得到的结果集的条数的次数

定义：访问次数取决于对驱动表执行单表查询后的结果集中的记录条数的连接执行方式

评价：最简单，也是最笨拙的一种连接查询算法

**使用索引加快连接速度**

在`嵌套循环连接`的`步骤二`中，我们可能需要多次访问被驱动表，每一次访问，相当于一次单表扫描，在这个过程中，我们可以通过**建立索引**来加快查询速度。

**特别地！**

若被驱动表中，搜索条件涉及的列是被驱动表的主键或者是唯一二级索引列，那么使用等值查找从被驱动表中查找记录的过程的代价就是常数级别的。

这种在连接查询中对驱动表使用主键值或者唯一二级索引列的值进行等值查找的查询执行方式称为 `eq—_ref`

> 索引的使用与否、使用哪个索引，取决于使用代价。

#### 基于块的嵌套循环链接（`Block Nested-Loop Join`）

情况：现实生产中表中数据很多，访问一次被驱动表可能就要进行多次`I/O`读取，这与访问被驱动表的次数相乘，`I/O`代价就会变得更大了

目的：减少访问被驱动表的次数

原理：原先是一条驱动表记录就要与被驱动表全表记录匹配一次，通过执行连接查询前申请一块固定大小的内存`join buffer`，先将多条驱动表记录存储在`join buffer`中，每一次对被驱动表全表扫描都可以和`join buffer`中多条驱动表记录进行匹配，从而显著减少被驱动表的`I/O`代价

定义：加入了`join buffer`的嵌套循环连接算法称之为`基于块的嵌套连接`（Block Nested-Loop Join）算法

**关于`join buffer`**

**设置：**可以通过启动参数或者系统变量`join_buffer_size`进行配置，默认大小为`262144字节`（也就是`256KB`），最小可以设置为`128字节`

**建议：**最好是为被驱动表加上效率高的索引，如果实在不能使用索引，并且自己的机器的内存也比较大可以尝试调大`join_buffer_size`的值来对连接查询进行优化。

**特别地！**驱动表记录并不是所有列都会被存放到`join buffer`中，只有查询列表中的列和过滤条件中的列才会被放到`join buffer`中，**所以再次建议，不要用`*`作为查询列表，只需要把实际需要的列放到查询列表，不仅能更好地利用索引，还能在`join buffer`中放更多的记录。**


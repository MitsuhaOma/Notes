单表查询语句本质上是一种声明性的语法，它封装了底层的实现，它实现了只需要指定列名，表名，条件等需要设置的部分，我们就可以获得数据

查询方式大致分为以下两种：

- 使用索引

  使用索引来执行查询可能可以加快查询执行的时间。

- 全表扫描

  将表的每一行记录都扫描一遍，把符合条件的记录加入到结果集，任何查询都可以用全表扫描实现，但是比较低效

----

访问方法：`MySQL`执行查询语句的方式

#### `const`

对于聚簇索引和唯一二级索引，在进行和一个常数进行等值比较时，才进行`const`访问方法

#### `ref`

定义：搜索条件为二级索引列**与常数等值比较**，采用普通二级索引来执行查询的访问方法

对象：普通二级索引，存在值重复的情况

影响：使用二级索引来执行查询时等值匹配到的二级索引记录条数，匹配记录越少，回表代价越低

特别的情况：

- 二级索引列值为`NULL`的情况

  不论是普通的二级索引，还是唯一二级索引，它们的索引列对包含`NULL`值的数量并不限制，所以当我们搜索条件为`WHERE key IS NULL`，在唯一二级索引中会选择`ref`的访问方法，而不是更高效的`const`访问方法

- 对于某个包含多个索引列的二级索引来说，只要**最左边的连续索引列**是**与常数的等值比较**，就有可能采用`ref`的访问方法，

####  `ref_of_null`

目的：找出某个二级索引列的值等于某个常数的记录，还想把该列的值为`NULL`的记录也找出来

要求：使用二级索引来完成查询，其余同`ref`

#### `range `

定义：利用索引进行范围匹配的访问方法

拓展：

- 索引列单值匹配的情况叫做**单点区间**
- 索引列范围匹配的情况叫做**连续范围区间**

#### `index`

定义：**遍历**二级索引记录的执行方式

条件：

- 理论上，该搜索条件应属于联合索引，但是由于最左前缀法则限制，无法直接使用已建好的联合索引直接进行查询。
- 查询结果需要返回的列应包括在建立联合索引的列中

原因：直接遍历二级索引且不用回表操作的查找的成本，要小于直接遍历聚簇索引的成本

#### `all`

定义：全表扫描执行查询的方式

-----

#### `二级索引+回表`

一般情况下，只能利用单个二级索引来执行查询。

当出现多个搜索条件时，优化器一般会根据表中的统计数据来判断到底是用那个条件到对应的二级索引中查询扫描的行数会更少，选择那个扫描行数较少的条件到对应的二级索引中查询。

> 这很容易理解，因为扫描行数较少意味着更少的回表操作

一般而言，等值查询比范围查找需要扫描的行数更少（也就是`ref`访问方式一般比`range`好，但也不绝对，也可能存在等值查询对应的行数特别多的情况）。

####  明确`range`访问方法使用的范围区别

区间的诞生：对于B+树而言，只要在`WHERE`后面，将索引列和常数使用`=`、`IN`、`NOT IN`、`IS NULL`、`IS NOT NULL`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`!=`(`<>`)或者`LIKE`操作符连接起来，就可以产生一个所谓的区间。

#### 当出现多个搜索条件，但同时有的搜索条件无法使用索引

在对应索引中，索引列相关的搜索条件，可以生效，用不到相关索引的搜索条件会被默认替换为`TRUE`。

**但是！！！**

只有当搜索条件用`AND`连接时，索引类相关的搜索条件可以生效，就相当于，`WHERE 搜索条件`被简化为了`WHERE 与索引列相关的搜索条件`

但是如果用`OR`链接，`WHERE 搜索条件`会被简化为`WHERE TRUE`，就相当于把所有的二级索引记录进行回表，（当然优化器会选择转而使用全表扫描）

因此我们可以得出结论，当一个使用到索引的搜索条件和没有使用该索引的搜索条件用`OR`连接起来后是无法使用该索引的。

----

#### 索引合并

`index merge`：使用多个索引来完成一次查询的执行方法

具体的索引合并算法有以下三种。

**`intersection`合并**：求交集

**条件：**

- 搜索条件用`AND`链接
- 搜索条件所涉及的列都已经建立了索引

**做法：**通过索引列的搜索条件从各自的二级索引中取出相关记录，再对主键值求交集，再进行回表操作

**节省原理：**虽然读取多个二级索引比读取一个二级索引消耗性能，但是读取二级索引的操作是`顺序I/O`，而回表操作是`随机I/O`，所以如果只读取一个二级索引时需要回表的记录数特别多，而读取多个二级索引之后取交集的记录数非常少，当节省的因为`回表`而造成的性能损耗比访问多个二级索引带来的性能损耗更高时，读取多个二级索引后取交集比只读取一个二级索引的成本更低。

**使用场景 **

- 情况一：想同时使用二级索引和联合索引来完成一次查询，当二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。
- 情况二：当同时使用二级索引和聚簇索引进行`Intersection`索引合并的操作时，主键列允许是范围匹配，索引列还得是等值匹配

**具体情况**

上述使用场景只是`Intersection`索引合并的必要条件，而不是充分条件。也就是说，使用场景成立，也不一定发生`Intersection`索引合并。

优化器只有在单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，而通过`Intersection`索引合并后需要回表的记录数大大减少的时才会使用`Intersection`索引合并

**`Union`合并：求并集**

**条件：**

- 搜索条件用`OR`链接
- 搜索条件所涉及的列都已经建立了索引

**使用场景：**

- 情况一：想同时使用二级索引和联合索引来完成一次查询，当二级索引列是等值匹配的情况，对于联合索引来说，在联合索引中的每个列都必须等值匹配，不能出现只匹配部分列的情况。
- 情况二：当同时使用二级索引和聚簇索引进行`Intersection`索引合并的操作时，主键列允许是范围匹配，索引列还得是等值匹配
- 情况三：使用`Intersection`索引合并的搜索条件

**具体情况**

与`Intersection`索引合并相同，取决于使用`Union`合并进行访问的代价能否小于全表扫描

**`Sort-Union`合并：拓展的`Union`合并**

**原因：**`Union`索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到。这是因为我们需要从不同的索引条件中获得有序的主键序列，等值匹配可以获得有序的主键序列，但是范围匹配不行。

**做法：**

根据搜索条件（范围区间），从二级索引中获取记录，并根据记录的主键值进行排序，这就获得了有序的主键序列，继而就可以像`Union`合并方式一样了。

**很明显**，这种`Sort-Union`索引合并比单纯的`Union`索引合并多了一步对二级索引记录的主键值排序的过程

**适用场景：**

根据每个搜索条件从二级索引中获得的记录数比较少的情况。

#### 比较

`Sort-Union`的适用场景是单独根据搜索条件从某个二级索引中获取的记录数比较少，这样即使对这些二级索引记录按照主键值进行排序的成本也不会太高 

`Intersection`索引合并的适用场景是单独根据搜索条件从某个二级索引中获取的记录数太多，导致回表开销太大，合并后可以明显降低回表开销，